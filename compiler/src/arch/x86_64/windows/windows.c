#include "windows.h"
#include "../nasm.h"
#include "../common.h"

int WINDOWS_GPR_ARGS[] = {
    REG_C,
    REG_D,
    REG_R8,
    REG_R9
};
void compile_nasm_x86_64_windows(CompileState* state) {
    if(!build_options.experimental_windows) {
        eprintfln("ERROR: compile_nasm_x86_64_windows is still very much not supported as there's quite a few differences between windows and linux. Please use something like WSL until we have this all sorted. Or you could add the --experimental-windows flag which will allow you to continue with this janky and unfinished target");
        exit(1);
    }
    eprintfln("ERROR: Windows support has been completely removed for now");
    exit(1);
#if 0
    state->f = fopen(state->target->opath, "wb");
    if(!state->f) {
        eprintfln("ERROR: Could not open output file %s: %s",state->target->opath,strerror(errno));
        exit(1);
    }
    nprintfln("[BITS 64]");
    nprintfln("; Generated by the C prototype compiler");
    nprintfln("; Target: %s %s",platform_str(state->target->platform), arch_str(state->target->arch));
    nprintfln("section .text");
    for(size_t i = 0; i < state->build->funcs.len; ++i) {
        nasm_gpr_reset(&state->regs);
        BuildFunc* func = &state->build->funcs.items[i];
        Type* type = type_table_get(&state->build->type_table, func->typeid);
        assert(type);
        assert(type->core == CORE_FUNC);
        FuncSignature* sig = &type->signature;

        for(size_t j = 0; j < sig->input.len && j < ARRAY_LEN(WINDOWS_GPR_ARGS); ++j) {
            nasm_gpr_occupy(&state->regs, WINDOWS_GPR_ARGS[j]);
        }
        nprintfln("global %s",func->name->data);
        nprintfln("%s:",func->name->data);
        nprintfln("   push rbp");
        nprintfln("   mov rbp, rsp");
        size_t vals_count = func->ip;
        CompileValue* vals = (CompileValue*)arena_alloc(state->arena, sizeof(CompileValue)*vals_count);
        if(!vals) {
            eprintfln("ERROR: Failed to allocate temporary vals buffer");
            exit(1);
        }
        memset(vals, 0, sizeof(CompileValue)*vals_count);
        size_t ip = 0;
        size_t rsp = 0;
        for(size_t j = 0; j < func->blocks.len; ++j) {
            // TODO: Deallocate this at the end since its at the top of the arena
            Block* block = &func->blocks.items[j];
            nprintfln(".%zu:",j);
            for(size_t k = 0; k < block->len; ++k, ++ip) {
                BuildInst* inst = &block->items[k];
                static_assert(BUILD_INST_COUNT == 6);
                switch(inst->kind) {
                case BUILD_LOAD_ARG: {
                    assert(inst->arg < sig->input.len);
                    Arg* arg = &sig->input.items[inst->arg];
                    Type* argtype = type_table_get(&state->build->type_table, arg->typeid);
                    switch(inst->arg) {
                    case 0:
                    case 1:
                    case 2:
                    case 3:
                       size_t regsize = 0;
                       if(argtype->core != CORE_I32) {
                           eprintfln("TODO: Core type: %d is not implemented", argtype->core);
                           exit(1);
                       }
                       regsize = REG_SIZE_32;
                       vals[ip] = (CompileValue){.kind=CVALUE_REGISTER, .reg=WINDOWS_GPR_ARGS[inst->arg], .regsize=regsize};
                       break; 
                    default:
                       eprintfln("Argument %zu is not implemented",inst->arg);
                       exit(1);
                    }
                } break;
                case BUILD_ADD_INT: {
                    assert(inst->v0 < ip && inst->v1 < ip); // It is a previous instruction.
                    CompileValue* v0 = &vals[inst->v0];
                    CompileValue* v1 = &vals[inst->v1];

                    assert(v0->kind == CVALUE_REGISTER);
                    assert(v1->kind == CVALUE_REGISTER);
                    assert(v0->regsize == v1->regsize);
                    CompileValue  result = compile_value_alloc(state, v0->regsize);
                    assert(result.kind == CVALUE_REGISTER);
                    nprintfln("   lea %s, [%s+%s]", nasm_gpr_to_str(result.reg, result.regsize), nasm_gpr_to_str(v0->reg, REG_SIZE_64), nasm_gpr_to_str(v1->reg, REG_SIZE_64));
                    // nprintfln("   mov %s, %s", nasm_gpr_to_str(result.reg, result.regsize), nasm_gpr_to_str(v0->reg   , v0->regsize   ));
                    // nprintfln("   add %s, %s", nasm_gpr_to_str(result.reg, result.regsize), nasm_gpr_to_str(v1->reg   , v1->regsize   ));
                    vals[ip] = result;
                } break;
                case BUILD_RETURN: {
                    assert(inst->arg < ip); // It is a previous instruction.
                    CompileValue value = {0};
                    CompileValue* arg = &vals[inst->arg];
                    if(arg->kind == CVALUE_REGISTER && arg->reg == REG_A) {
                        nprintfln("   pop rbp");
                        nprintfln("   ret");
                        break;
                    }
                    assert(arg->kind == CVALUE_REGISTER);
                    value.reg = REG_A;
                    value.regsize = arg->regsize;
                    nprintfln("   mov %s, %s",nasm_gpr_to_str(value.reg, value.regsize), nasm_gpr_to_str(arg->reg, arg->regsize));
                    nprintfln("   pop rbp");
                    nprintfln("   ret");
                } break;
                case BUILD_ALLOCA: {
                    nprintfln("   sub rsp, %zu",inst->size);
                    CompileValue* result = &vals[ip];
                    result->kind = CVALUE_STACK_PTR;
                    result->stack_ptr = rsp;
                    result->type = inst->type;
                    rsp+=inst->size;
                } break;
                default:
                    eprintfln("Unhandled instruction %d", inst->kind);
                    exit(1);
                }
            }
        }
    }
    fclose(state->f);
#endif
}
