#include "qbe.h"
#include "../darray.h"
#include <errno.h>
typedef struct {
    Atom* name; 
    size_t unnamed_i;
    enum {
        GLOBAL_ARRAY
    } kind;
    struct { Type* type; const void* data; size_t len; } array;
} QbeGlobal;
typedef struct {
    QbeGlobal* items;
    size_t len, cap;
    size_t unnamed_i;
} QbeGlobals;
typedef struct {
    Build* build;
    ProgramState* state;
    FILE* f;
    QbeGlobals globals;
    size_t inst;
} Qbe;
#define nprintf(...) do { \
       if(fprintf(qbe->f, __VA_ARGS__) < 0) {\
           eprintfln("ERROR: Failed to encode something");\
           return false;\
       }\
   } while(0)
#define nprintfln(...) do {\
       nprintf(__VA_ARGS__);\
       fputs(NEWLINE, qbe->f);\
   } while(0)
bool dump_type_to_qbe_full(Qbe* qbe, Type* t) {
    assert(t);
    assert(t->core != CORE_FUNC);
    switch(t->core) {
    case CORE_PTR:
        nprintf("l");
        break;
    case CORE_I8:
        if(t->unsign) nprintf("u");
        else nprintf("s");
        nprintf("b");
        break;
    case CORE_I32:
        nprintf("w");
        break;
    default:
        eprintfln("(dump_type_to_qbe) UNREACHABLE");
        return false;
    }
    return true;
}
bool dump_type_to_qbe(Qbe* qbe, Type* t) {
    assert(t);
    assert(t->core != CORE_FUNC);
    switch(t->core) {
    case CORE_PTR:
        nprintf("l");
        break;
    case CORE_I8:
    case CORE_I32:
        nprintf("w");
        break;
    default:
        eprintfln("(dump_type_to_qbe) UNREACHABLE");
        return false;
    }
    return true;
}
size_t build_qbe_ast(Qbe* qbe, AST* ast) {
    size_t n=0;
    static_assert(AST_KIND_COUNT == 262, "Update build_qbe_ast");
    switch(ast->kind) {
    case '+':
        size_t v0 = build_qbe_ast(qbe, ast->as.binop.lhs);
        size_t v1 = build_qbe_ast(qbe, ast->as.binop.rhs);
        if(!v0 || !v1) return 0;
        nprintf("    %%s%zu =", n=qbe->inst++);dump_type_to_qbe(qbe, ast->as.binop.lhs->type);nprintfln(" add %%s%zu, %%s%zu", v0, v1);
        break;
    case AST_CALL: {
        assert(ast->as.call.what->kind == AST_SYMBOL);
        struct {
            size_t *items;
            size_t len, cap;
        } result_args = {0};
        CallArgs* args = &ast->as.call.args;
        for(size_t i = 0; i < args->len; ++i) {
            size_t v = build_qbe_ast(qbe, args->items[i]);
            if(!v) return 0;
            da_push(&result_args, v);
        }
        if(ast->type) {
            nprintf("    %%s%zu =", n=qbe->inst++);dump_type_to_qbe(qbe, ast->type);
        }
        nprintf("    call $%s(", ast->as.call.what->as.symbol->data);
        for(size_t i = 0; i < args->len; ++i) {
            if(i > 0) nprintf(", ");
            dump_type_to_qbe(qbe, args->items[i]->type);nprintf(" %%s%zu", result_args.items[i]);
        }
        nprintfln(")");
        free(args->items);
    } break;
    case AST_C_STR: {
        QbeGlobal global = {0};
        global.name = NULL;
        global.unnamed_i = qbe->globals.unnamed_i++;
        global.kind = GLOBAL_ARRAY;
        global.array.type = &type_u8;
        global.array.data = ast->as.str.str;
        global.array.len  = ast->as.str.len+1;
        da_push(&qbe->globals, global);
        nprintf("    %%s%zu =", n=qbe->inst++);nprintfln("l copy $.g%zu", global.unnamed_i);
    } break;
    case AST_DEREF: {
        size_t v0 = build_qbe_ast(qbe, ast->as.deref.what);
        nprintf("    %%s%zu =", n=qbe->inst++); dump_type_to_qbe(qbe, ast->type);nprintf(" load");dump_type_to_qbe_full(qbe, ast->type); nprintfln(" %%s%zu", v0);
    } break;
    case AST_INT: 
        nprintf("    %%s%zu =", n=qbe->inst++);dump_type_to_qbe(qbe, ast->type);nprintfln(" copy %lu", ast->as.integer.value);
        break;
    case AST_SYMBOL:
        nprintf("    %%s%zu =", n=qbe->inst++);dump_type_to_qbe(qbe, ast->type);nprintfln(" copy %%%s", ast->as.symbol->data);
        break;
    default:
        eprintfln("ERROR: Unsupported. I guess :( %d (build_qbe_ast)", ast->kind);
        exit(1);
        break;
    }
    return n;
}
bool build_qbe_qbe(Qbe* qbe) {
    nprintfln("# Generated by lewc compiler");
    nprintfln("# Target: %s %s", platform_str(qbe->build->target->platform), arch_str(qbe->build->target->arch));
    for(size_t i = 0; i < qbe->state->funcs.buckets.len; ++i) {
        for(
            Pair_FuncMap* fpair = qbe->state->funcs.buckets.items[i].first;
            fpair;
            fpair = fpair->next
        ) {
            qbe->inst = 1;
            Atom* name     = fpair->key;
            Function* func = &fpair->value;
            assert(func->type->core == CORE_FUNC);
            // I think QBE automatically assumes external function
            if(func->type->attribs & TYPE_ATTRIB_EXTERN) {
                nprintf("# extern %s :: ", name->data);
                type_dump(qbe->f, func->type);
                nprintf("%s", NEWLINE);
                continue;
            }
            nprintf("# %s :: ", name->data);
            type_dump(qbe->f, func->type);
            nprintf("%s", NEWLINE);
            nprintf("export function ");
            if(func->type->signature.output) dump_type_to_qbe(qbe, func->type->signature.output);
            nprintf(" $%s (", name->data);
            for(size_t i = 0; i < func->type->signature.input.len; ++i) {
                if(i > 0) nprintf(", ");
                Arg* arg = &func->type->signature.input.items[i];
                dump_type_to_qbe(qbe, arg->type);
                if(arg->name) nprintf(" %%%s", arg->name->data);
            }
            nprintfln(") {");
            nprintfln("@start");
            for(size_t j = 0; j < func->scope->len; ++j) {
                Statement* statement = func->scope->items[j];
                static_assert(STATEMENT_COUNT == 2, "Update build_qbe_qbe");
                size_t n = 0;
                switch(statement->kind) {
                case STATEMENT_EVAL:
                    build_qbe_ast(qbe, statement->as.ast);
                    break;
                case STATEMENT_RETURN:
                    n = build_qbe_ast(qbe, statement->as.ast);
                    nprintfln("    ret %%s%zu", n);
                    break;
                }
            }
            nprintfln("}");
        }
    }
    for(size_t i = 0; i < qbe->globals.len; ++i) {
        QbeGlobal* global = &qbe->globals.items[i];
        assert(global->kind == GLOBAL_ARRAY);
        assert(global->array.type->core == CORE_I8);
        assert(global->name == NULL);
        nprintf("data $.g%zu = {", global->unnamed_i);
        for(size_t j = 0; j < global->array.len; ++j) {
            if(j > 0) nprintf(", ");
            nprintf("b %d", ((uint8_t*)global->array.data)[j]);
        }
        nprintfln(" }");
    }
    return true;
}
bool build_qbe(Build* build, ProgramState* state) {
    // TODO: Its more correct to call it SysV
    assert(build->target->platform == OS_LINUX);
    assert(build->target->arch == ARCH_X86_64);
    assert(build->target->outputKind == OUTPUT_GAS);
    Qbe qbe = {
        .build = build,
        .state = state,
        .f = NULL
    };
    char ssa_path[1024];
    size_t opath_len = strlen(build->options->opath);
    assert((opath_len + 4 + 1) <= sizeof(ssa_path));
    memcpy(ssa_path, build->options->opath, opath_len);
    strcpy(ssa_path+opath_len, ".ssa");
    qbe.f = fopen(ssa_path, "wb");
    if(!qbe.f) {
        eprintfln("ERROR: Could not open output file %s: %s", ssa_path, strerror(errno));
        return false;
    }
    if(!build_qbe_qbe(&qbe)) {
        fclose(qbe.f);
        return false;
    }
    fclose(qbe.f);
    // More than enough for everyone
    char* cmd = malloc(4096);
    if(!cmd) {
        eprintfln("ERROR: Not enough memory for cmd");
        return false;
    }
    strcpy(cmd, "qbe ");
    strcat(cmd, ssa_path);
    strcat(cmd, " -o ");
    strcat(cmd, build->options->opath);
    int e = system(cmd);
    free(cmd);
    if(e != 0) {
        eprintfln("ERROR: Failed to build with qbe");
        return false;
    }
    return true;
}
