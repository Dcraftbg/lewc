#include "linux.h"
#include "../nasm.h"
#include "../common.h"
#include <errno.h>

int LINUX_GPR_ARGS[] = {
     REG_DI,
     REG_SI,
     REG_D,
     REG_R10,
     REG_R8,
     REG_R9
};
void compile_nasm_x86_64_linux(CompileState* state) {
    state->f = fopen(state->target->opath, "wb");
    if(!state->f) {
        eprintfln("ERROR: Could not open output file %s: %s",state->target->opath,strerror(errno));
        exit(1);
    }
    nprintfln("[BITS 64]");
    nprintfln("; Generated by the C prototype compiler");
    nprintfln("; Target: %s %s",platform_str(state->target->platform), arch_str(state->target->arch));
    nprintfln("section .data");
    nprintfln("@globals:");
    for(size_t i = 0; i < state->build->globals.len; ++i) {
        static_assert(GLOBAL_KIND_COUNT==1, "Update globals");
        BuildGlobal* global = &state->build->globals.items[i];
        switch(global->kind) {
        case GLOBAL_ARRAY: {
            nprintfln(".G%zu:",i);
            Type* type = global->array.typeid;
            assert(type->core == CORE_I8 && type->ptr_count == 0);
            nprintf(" db ");
            for(size_t i = 0; i < global->array.len; ++i) {
                 if(i != 0) nprintf(", ");
                 nprintf("%u", ((uint8_t*)global->array.data)[i]);
            }
            nprintfln(" ; End of Global");
        } break;
        default:
            assert(false && "Unreachable");
        }
    }
    nprintfln("section .text");
    for(size_t i = 0; i < state->build->funcs.len; ++i) {
        nasm_gpr_reset(&state->regs);
        BuildFunc* func = &state->build->funcs.items[i];
        Type* type = func->typeid;
        assert(type);
        assert(type->core == CORE_FUNC);
        if(type->attribs & TYPE_ATTRIB_EXTERN) {
            nprintfln("extern %s",func->name->data);
        } else {
            FuncSignature* sig = &type->signature;

            for(size_t j = 0; j < sig->input.len && j < ARRAY_LEN(LINUX_GPR_ARGS); ++j) {
                nasm_gpr_occupy(&state->regs, LINUX_GPR_ARGS[j]);
            }
            nprintfln("global %s",func->name->data);
            nprintfln("%s:",func->name->data);
            nprintfln("   push rbp");
            nprintfln("   mov rbp, rsp");
            size_t vals_count = func->ip;
            CompileValue* vals = (CompileValue*)arena_alloc(state->arena, sizeof(CompileValue)*vals_count);
            if(!vals) {
                eprintfln("ERROR: Failed to allocate temporary vals buffer");
                exit(1);
            }
            memset(vals, 0, sizeof(CompileValue)*vals_count);
            size_t ip = 0;
            size_t rsp = 0;
            for(size_t j = 0; j < func->blocks.len; ++j) {
                // TODO: Deallocate this at the end since its at the top of the arena
                Block* block = &func->blocks.items[j];
                nprintfln(".%zu:",j);
                for(size_t k = 0; k < block->len; ++k, ++ip) {
                    BuildInst* inst = &block->items[k];
                    static_assert(BUILD_INST_COUNT == 9);
                    switch(inst->kind) {
                    case BUILD_LOAD_ARG: {
                        assert(inst->arg < sig->input.len);
                        Arg* arg = &sig->input.items[inst->arg];
                        Type* argtype = arg->type;
                        switch(inst->arg) {
                        case 0:
                        case 1:
                        case 2:
                        case 3:
                           size_t regsize = 0;
                           if(argtype->core != CORE_I32) {
                               eprintfln("TODO: Core type: %d is not implemented", argtype->core);
                               exit(1);
                           }
                           regsize = REG_SIZE_32;
                           vals[ip] = (CompileValue){.kind=CVALUE_REGISTER, .reg=LINUX_GPR_ARGS[inst->arg], .regsize=regsize};
                           break; 
                        default:
                           eprintfln("Argument %zu is not implemented",inst->arg);
                           exit(1);
                        }
                    } break;
                    case BUILD_ADD_INT: {
                        assert(inst->v0 < ip && inst->v1 < ip); // It is a previous instruction.
                        CompileValue* v0 = &vals[inst->v0];
                        CompileValue* v1 = &vals[inst->v1];
                        CompileValue* result = &vals[ip];
                        switch(v0->kind) {
                        case CVALUE_REGISTER: {
                            switch(v1->kind) {
                            case CVALUE_REGISTER: {
                                assert(v0->regsize == v1->regsize);
                                *result = compile_value_alloc(state, v0->regsize);
                                assert(result->kind == CVALUE_REGISTER);
                                nprintfln("   lea %s, [%s+%s]", nasm_gpr_to_str(result->reg, result->regsize), nasm_gpr_to_str(v0->reg, REG_SIZE_64), nasm_gpr_to_str(v1->reg, REG_SIZE_64));
                            } break;
                            case CVALUE_CONST_INT: {
                                if(v1->integer.value) {
                                    *result = compile_value_alloc(state, v0->regsize);
                                    assert(result->kind == CVALUE_REGISTER);
                                    nprintfln("   lea %s, [%s+%lu]", nasm_gpr_to_str(result->reg, result->regsize), nasm_gpr_to_str(v0->reg, REG_SIZE_64), v1->integer.value);
                                } else {
                                    *result = *v0;
                                }
                            } break;
                            }
                        } break;
                        case CVALUE_CONST_INT: {
                            switch(v1->kind) {
                            case CVALUE_REGISTER: {
                                if(v0->integer.value) {
                                    *result = compile_value_alloc(state, v1->regsize);
                                    assert(result->kind == CVALUE_REGISTER);
                                    nprintfln("   lea %s, [%s+%lu]", nasm_gpr_to_str(result->reg, result->regsize), nasm_gpr_to_str(v1->reg, REG_SIZE_64), v0->integer.value);
                                } else {
                                    *result = *v1;
                                }
                            } break;
                            case CVALUE_CONST_INT: {
                                result->kind = CVALUE_CONST_INT;
                                result->integer.type = v0->integer.type;
                                result->integer.value = v0->integer.value + v1->integer.value;
                            } break;
                            }
                        } break;
                        }
                    } break;
                    case BUILD_RETURN: {
                        assert(inst->arg < ip); // It is a previous instruction.
                        CompileValue value = {0};
                        CompileValue* arg = &vals[inst->arg];
                        if(arg->kind == CVALUE_REGISTER && arg->reg == REG_A) {
                            if(rsp) nprintfln("   add rsp, %zu",rsp);
                            nprintfln("   pop rbp");
                            nprintfln("   ret");
                            break;
                        }

                        value.reg = REG_A;
                        switch(arg->kind) {
                        case CVALUE_REGISTER:
                            value.regsize = arg->regsize;
                            nprintfln("   mov %s, %s", nasm_gpr_to_str(value.reg, value.regsize), nasm_gpr_to_str(arg->reg, arg->regsize));
                            if(rsp) nprintfln("   add rsp, %zu",rsp);
                            nprintfln("   pop rbp");
                            nprintfln("   ret");
                            break;
                        case CVALUE_CONST_INT:
                            if(arg->integer.type == &type_i32) {
                                value.regsize = REG_SIZE_32;
                            } else {
                                eprintfln("Invalid const int return with typeid=%p", arg->integer.type);
                                exit(1);
                            }
                            const char* reg =  nasm_gpr_to_str(value.reg, value.regsize);
                            if(arg->integer.value == 0) {
                                nprintfln("   xor %s, %s", reg, reg);
                            } else {
                                nprintfln("   mov %s, %lu", reg, arg->integer.value);
                            }
                            if(rsp) nprintfln("   add rsp, %zu",rsp);
                            nprintfln("   pop rbp");
                            nprintfln("   ret");
                            break;
                        default:
                            eprintfln("%s:%u: Unsupported CVALUE_REGISTER in BUILD_RETURN", __FILE__, __LINE__);
                            break;
                        }
                    } break;
                    case BUILD_ALLOCA: {
                        Type* t = inst->type;
                        size_t size = type_get_size(t);
                        assert(size && "Unsupported types with size=0 for alloca");
                        size += (rsp+size+8) % 16;
                        nprintfln("   sub rsp, %zu", size);
                        CompileValue* result = &vals[ip];
                        rsp+=size;
                        result->kind = CVALUE_STACK_PTR;
                        result->stack_ptr = rsp;
                        result->type = inst->type;
                    } break;
                    case BUILD_LOAD_INT: {
                        assert(inst->arg < ip);
                        CompileValue* ptr = &vals[inst->arg];
                        assert(ptr->kind == CVALUE_STACK_PTR);
                        Type* t = ptr->type;
                        assert(t->core == CORE_I32 && "Unsupported types in iload");
                        CompileValue* result = &vals[ip];
                        *result = compile_value_alloc(state, REG_SIZE_32);
                        assert(result->kind == CVALUE_REGISTER);
                        nprintfln("   mov %s, [rbp-%zu]",nasm_gpr_to_str(result->reg, result->regsize),ptr->stack_ptr);
                    } break;
                    case BUILD_CONST_INT: {
                        CompileValue* result = &vals[ip];
                        result->kind = CVALUE_CONST_INT;
                        result->integer.type  = inst->integer.type;
                        result->integer.value = inst->integer.value;
                    } break;
                    case BUILD_STORE_INT: {
                        assert(inst->arg < ip);
                        CompileValue* ptr = &vals[inst->v0];
                        CompileValue* source = &vals[inst->v1];
                        assert(source->kind == CVALUE_REGISTER);
                        assert(ptr->kind == CVALUE_STACK_PTR);
                        nprintfln("   mov [rbp-%zu], %s",ptr->stack_ptr,nasm_gpr_to_str(source->reg, source->regsize));
                    } break;
                    case BUILD_GET_ADDR_OF: {
                        CompileValue* result = &vals[ip];
                        *result = compile_value_alloc(state, REG_SIZE_64);
                        assert(result->kind == CVALUE_REGISTER);
                        nprintfln("   lea %s, [rel @globals.G%zu]", nasm_gpr_to_str(result->reg, result->regsize), inst->globalid);
                    } break;
                    // TODO: non void function calls
                    case BUILD_CALL_DIRECTLY: {
                        BuildFunc* func = &state->build->funcs.items[inst->directcall.fid];
                        size_t pushed_rsp = 0;
                        for(size_t i = 0; i < inst->directcall.args.len; ++i) {
                            assert(i < ARRAY_LEN(LINUX_GPR_ARGS));
                            if(!nasm_gpr_is_free(&state->regs, LINUX_GPR_ARGS[i])) {
                                nprintfln("   push %s", nasm_gpr_to_str(LINUX_GPR_ARGS[i], REG_SIZE_64));
                                pushed_rsp+=8;
                            }
                            CompileValue* val = &vals[inst->directcall.args.items[i]];
                            switch(val->kind) {
                            case CVALUE_REGISTER:
                                nprintfln("   mov %s, %s", nasm_gpr_to_str(LINUX_GPR_ARGS[i], val->regsize), nasm_gpr_to_str(val->reg, val->regsize));
                                break;
                            case CVALUE_CONST_INT:
                                // TODO: Unhardcode register size
                                nprintfln("   mov %s, %lu", nasm_gpr_to_str(LINUX_GPR_ARGS[i], REG_SIZE_32), val->integer.value);
                                break;
                            default:
                                eprintfln("%s:%u: ERROR: Unsupported cvalue type %d in BUILD_CALL_DIRECTLY arguemnts", __FILE__, __LINE__, val->kind);
                                exit(1);
                            }
                        }
                        if(pushed_rsp % 16 != 0) {
                            nprintfln("   sub rsp, %zu", pushed_rsp%16);
                        }
                        nprintfln("   call %s",func->name->data);
                        if(pushed_rsp % 16 != 0) {
                            nprintfln("   add rsp, %zu", pushed_rsp%16);
                        }
                        for(size_t i = 0; i < inst->directcall.args.len; ++i) {
                            assert(i < ARRAY_LEN(LINUX_GPR_ARGS));
                            if(!nasm_gpr_is_free(&state->regs, LINUX_GPR_ARGS[i])) nprintfln("   pop %s", nasm_gpr_to_str(LINUX_GPR_ARGS[i], REG_SIZE_64));
                        }

                        // TODO: Assumes result returns i32
                        CompileValue* result = &vals[ip];
                        result->reg = REG_A;
                        result->regsize = REG_SIZE_32;
                    } break;
                    default:
                        eprintfln("Unhandled instruction %d", inst->kind);
                        exit(1);
                    }
                }
            }
        }
    }
    fclose(state->f);
}
